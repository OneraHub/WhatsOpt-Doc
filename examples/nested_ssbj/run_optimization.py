# -*- coding: utf-8 -*-
"""
  run_optimization.py generated by WhatsOpt. 
"""
# DO NOT EDIT unless you know what you are doing
# analysis_id: 99

import sys
import six
import numpy as np
# import matplotlib
# matplotlib.use('Agg')
import matplotlib.pyplot as plt
from openmdao.api import Problem, SqliteRecorder, CaseReader, ScipyOptimizeDriver #, pyOptSparseDriver
from ssbj_mda import SsbjMda 

# Use ssbj_openmdao as a module (required so that next from/import line work)
import os, sys
sys.path.append(os.path.join(os.path.dirname(__file__), "ssbj_openmdao"))

from ssbj_openmdao.ssbj_mda import init_ssbj_mda

from optparse import OptionParser
parser = OptionParser()
parser.add_option("-b", "--batch",
                  action="store_true", dest="batch", default=False,
                  help="do not plot anything")
(options, args) = parser.parse_args()

scalers = init_ssbj_mda()
pb = Problem(SsbjMda(scalers))

pb.driver = ScipyOptimizeDriver()
pb.driver.options['optimizer'] = 'SLSQP'


#pb.driver.options['tol'] = 1.0e-06

pb.driver.options['maxiter'] = 100

pb.driver.options['disp'] = True
#pb.driver.options['debug_print'] = ['desvars','ln_cons','nl_cons','objs', 'totals']

case_recorder_filename = 'ssbj_mda_optimization.sqlite'
print(case_recorder_filename)        
recorder = SqliteRecorder(case_recorder_filename)
# pb.add_recorder(recorder)
pb.driver.add_recorder(recorder)
pb.model.add_recorder(recorder)

# Derivatives are compute via finite-difference method
# to be commnented out if partial derivatives are declared
#pb.model.approx_totals(method='fd', step=1e-6, form='central')

pb.model.add_design_var('z', lower=[0.2, 0.666, 0.875, 0.45, 0.72, 0.5], upper=[1.8, 1.333, 1.125, 1.45, 1.27, 1.5])
pb.model.add_design_var('x_aer', lower=0.75, upper=1.25)
pb.model.add_design_var('x_str', lower=[0.4, 0.75], upper=[1.6, 1.25])
pb.model.add_design_var('x_pro', lower=0.18, upper=1.81)


pb.model.add_objective('R', scaler=-1)

pb.model.add_constraint('con1_esf', upper=0.)
pb.model.add_constraint('con2_esf', upper=0.)
pb.model.add_constraint('con_dpdx', upper=0.)
pb.model.add_constraint('con_dt', upper=0.)
pb.model.add_constraint('con_sigma1', upper=0.)
pb.model.add_constraint('con_sigma2', upper=0.)
pb.model.add_constraint('con_sigma3', upper=0.)
pb.model.add_constraint('con_sigma4', upper=0.)
pb.model.add_constraint('con_sigma5', upper=0.)
pb.model.add_constraint('con_temp', upper=0.)
pb.model.add_constraint('con_theta_low', upper=0.)
pb.model.add_constraint('con_theta_up', upper=0.)

pb.setup()  
pb.run_driver()      

pb.model.list_inputs()
pb.model.list_outputs()

print('Z_opt=', pb['z']*scalers['z'])
print('X_str_opt=', pb['x_str']*scalers['x_str'])
print('X_aer_opt=', pb['x_aer'])
print('X_pro_opt=', pb['x_pro']*scalers['x_pro'])
print('R_opt=', pb['R']*scalers['R'])
for key in six.iterkeys(scalers):
    if key not in ['z', 'x_str', 'x_pro']:
        print('{}: {} (scaler: {}, value: {})'.format(key, scalers[key]*pb[key], scalers[key], pb[key]))

if options.batch:
    exit(0)  
    
